## IOCTL函数用法

函数作用：==ioctl是设备驱动程序中对设备的I/O通道进行管理的函数 。==

所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。它的调用个数如下： 
int ioctl(int fd, ind cmd, …)； 
    其中**fd是用户程序打开设备时使用open函数返回的文件标示符**，cmd是用户程序对设备的控制命令，至于后面的省略号，那是一些补充参数，一般最多一个，这个参数的有无和cmd的意义相关。 
    ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数来控制设备的I/O通道。



### memset函数用法

**作用**：  memset 是一个初始化函数，作用是将某一块内存中的全部设置为指定的值。

函数定义：

```c
void *memset( void * s,int value, size_t n )
```

- s指向要填充的内存块。

- value是要被设置的值。

- n是要被设置该值的字符数。(即哪些内存设置zhi)

  注释size_t,这是一种数据类型，这种数据类型表示的是==记录大小==的

  比如   int a[4];      size_t  n  =  size of(a);

- 返回类型是一个指向存储区s的指针。

  举例：

  ```c
  memset(fb_base, 0xff, screen_size);
  ```

  0xff为一个字节大小。而每个像素点为4个字节，在这样赋值时，他会将每个字节都赋值为0xff。



### open函数

**头文件和功能:**

头文件：#include<fcntl.h>//在centos6.0中只要此头文件就可以
1      		 #include<sys/types.h>
 1   		  #incldue<sys/stat.h>
功能：打开和创建文件（建立一个文件描述符，**其他的函数可以通过==文件描述符==**对**指定文件进行读取与写入的操作**。）

**函数原型：**

```c
int open(const char*pathname,int flags);
int open(const char*pathname,int flags,mode_t mode);
参数说明：
1.pathname
  要打开或创建的目标文件     **设备也可以看成文件**
2.flags
  打开文件时，可以传入多个参数选项，用下面的
  一个或者多个常量进行“或”运算，构成falgs
  参数：
  O_RDONLY:   只读打开
  O_WRONLY:   只写打开
  O_RDWR:     读，写打开
这三个常量，必须制定一个且只能指定一个
  O_CREAT:    若文件不存在，则创建它，需要使
              用mode选项。来指明新文件的访问权限
  O_APPEND:   追加写，如果文件已经有内容，这次打开文件所
              写的数据附加到文件的末尾而不覆盖原来的内容
```

ps：open函数具体使用那个，和具体应用场景相关，如==目标文件存在，使用两个参数的open==，如果目标文件不存在，需要open创建，则第三个参数表示创建文件的默认权限

**返回值**：

```c
成功：新打开的文件描述符
失败：-1
open返回的文件描述符一定是最小的而且没有被使用的
```



## close函数

**头文件和函数功能**

头文件：#include<unistd.h>           功能：关闭一个已经打开的文件

**函数原型**

int close(int fd)
参数说明：
 fd：是**需要关闭的文件描述符**

**返回值**

成功：返回0；
失败：返回-1，并设置errno

==打开的文件描述符一定要记得关闭，否则资源会被大量的占用，导致内存不够==



1132421421423

13243214

2431234123















