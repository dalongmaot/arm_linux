### 基础知识

### 补码

**原码、 反码 、补码。（重中之重）****（计算机中二进制码都是**以补码进行存储** **运算！！！！！****的）。**

![Image](C:\Users\TIANFU~1\AppData\Local\Temp\Image.png)

**负数补码的计算。**（正数三码合一）
（十进制转二进制）
（1）、先求与该负数相对应的正整数的二进制代码，
（2）、然后将所有位取反，
（3）、末尾加1，不够位数时，左边补1

法2：（推荐！！！）
  (1）、先求与该负数相对应的正整数的二进制代码
（1）、首位不变，其他位取反
（2）、末位加 1 。

**负数补码转原码的计算**

（1）、先通过首位为1确定为负数

（2）、末位减1，不够向前取位
（3）、首位不变，其他位取反
（4）、将得到的二进制除去首位转化为10进制，然后取负号





## 位操作

**换位**  ：   使用^运算符。     假设 b 是一个位 1 或 0 ), 如果 b 为 1， 则  l ^ b 为 0: 如 果 b 为 0, 则 l 6 b 为 1。   

即    ^=   （ 1 <<  x）（x为一个数值）          将某个地址的第   x    位进行换位操作。



**置1**   ：   |=                             |=  （ 1<< x）(x是一个数值)     将某个地址第x位置1 



**置零**    ： &=  ~                            &= ~ （ 1<<  x)        将某个地址第x位置零。

1<< 0   代表把1左移0位           ==无论是0还是1**与上1**都还是其本身==

比如对一个寄存器进行操作：   *（unsigned int *）0x40010C0C（32位）   &=   ~（1<<0）这个操作是将该寄存器==第0位置0==

相当于这样操作  ：   把  0x40010C0C    原先地址里面的值    按位与上     0x40010C0C    地址里面的值左移0位并且取反。如下图   。

![image-20220629224253809](C:\Users\tianfuqiang\AppData\Roaming\Typora\typora-user-images\image-20220629224253809.png)

相与之后，除了将末位置零之外，其他位不变。



1<< ( 4 * N )   代表向左移动       N个4位    ，**==即把低4位看成一个整体   移动N位==**



#### 如何去除一个0，1二维数组的每一位。

0 1 1 0 1 0 0 0      bit  0  -> 7

1 1 0 0 0 0 1 1

例如一个二维数组，想顺序取出bit 0 -> 7.

1、定义一个指针* dot指向该数组。

2、unsigned char  byte = dot[i]

3、和1相与得原位置位

```c
for(b = 7; b >= 0; b++)
{
    bit[7 - b] = (byte & (1 << b)) >> b
}
```





##### 强制对地址进行指针类型转换

**地址的值只是一个常数**

(unsigned int *)0x500:将地址0x500强制转化为int型指针   **这里即把  ==(unsigned int *)0x500==  这一个整体看成一个指针变量，这个指针变量指向0x500这个地址。
*(unsigned int *)0x500=0x10：对地址为0x500的内容里面赋值为0x10



#### 字节  比特之间的换算及称呼

1字节（byte） =  8 比特（bit）   bit也成为位



## 操作符

| ：逻辑或运算符。

### ##指针



### 字符串和字符串函数

数组和指针都可以定义字符串，指针更好一些。

char  * head  =  “tianfuqiang”                   （head++）代表指针每加一次，他所指向的位置就递加一个，指向下一个位置。

指针定义字符串有它的**缺点**。就是==不能更改字符串里面的字面量==。



**数组名代表的是地址，表示该数组第一个元素的地址。**



指针变量大小为**8**个字节



![image-20220706102804622](https://raw.githubusercontent.com/dalongmaot/arm_linux/main/imgs/image-20220706102804622.png)



==计算机中存储器的容量是以***字节***为基本单位的==

指针和数组

***重要***

c语言中指针和数组的特殊表示关系

```c
int * a;
*(a + i)  =  a[i];
这里是一种特殊表示方式（就是这样定义的），a依然占8个字节，是一个指针变量。
```

关于函数的形参， 还有一点要注意。 只有在==函数原型==或==函数定义头==中， 才**可以用 int ar[ ]代替 int *  a**.

int sum (int ar[], int n);
int *ar 形式和 int ar[ ] 形式都表示 ar 是一个指向 int 的指针。 但是， int ar[ ]只能用于声明
形式参数。  





```c
int main(void)
{
    short dates[SIZE];
    short * pti;
    short index;
    double bills[SIZE];
    double * ptf;
    pti = dates;
    ptf = bills;
    printf("%23s %15s\n", "short", "double");
    for(index = 0; index < SIZE; index++)
    {
        printf("pointers + %d: %10p %10p\n", index, pti +index,ptf + index);
    }
    system("pause");
    return 0;

}
```

输出结果：![image-20220629201736481](C:\Users\tianfuqiang\AppData\Roaming\Typora\typora-user-images\image-20220629201736481.png)



可以看到**<u>指针变量加1</u>**，  他是变成数组下一个变量的地址。

![](C:\Users\tianfuqiang\AppData\Roaming\Typora\typora-user-images\image-20220629201920260.png)

显然可以看出该电脑是64位的电脑。   16^16^ = 2^64



### 编译时头文件的查找

<>    去编译器目录底下找，范围窄一些

“   ”     去编译器底下，同时去该程序所在的文件目录底下去找。







作弊经济![image-20220705001716824](E:\software\Typora\markdown笔记\编程学习\c语言学习.assets\image-20220705001716824.png)

