### 基础知识

### 补码

**原码、 反码 、补码。（重中之重）****（计算机中二进制码都是**以补码进行存储** **运算！！！！！****的）。**

![Image](C:\Users\TIANFU~1\AppData\Local\Temp\Image.png)

**负数补码的计算。**（正数三码合一）
（十进制转二进制）
（1）、先求与该负数相对应的正整数的二进制代码，
（2）、然后将所有位取反，
（3）、末尾加1，不够位数时，左边补1

法2：（推荐！！！）
  (1）、先求与该负数相对应的正整数的二进制代码
（1）、首位不变，其他位取反
（2）、末位加 1 。

**负数补码转原码的计算**

（1）、先通过首位为1确定为负数

（2）、末位减1，不够向前取位
（3）、首位不变，其他位取反
（4）、将得到的二进制除去首位转化为10进制，然后取负号



### c语言中不同类型字符所占字节大小

![image-20220708153723336](https://raw.githubusercontent.com/dalongmaot/arm_linux/main/imgs/image-20220708153723336.png)



## 位操作

**换位**  ：   使用^运算符。     假设 b 是一个位 1 或 0 ), 如果 b 为 1， 则  l ^ b 为 0: 如 果 b 为 0, 则 l 6 b 为 1。   

即    ^=   （ 1 <<  x）（x为一个数值）          将某个地址的第   x    位进行换位操作。



**置1**   ：   |=                             |=  （ 1<< x）(x是一个数值)     将某个地址第x位置1 



**置零**    ： &=  ~                            &= ~ （ 1<<  x)        将某个地址第x位置零。

1<< 0   代表把1左移0位           ==无论是0还是1**与上1**都还是其本身==

比如对一个寄存器进行操作：   *（unsigned int *）0x40010C0C（32位）   &=   ~（1<<0）这个操作是将该寄存器==第0位置0==

相当于这样操作  ：   把  0x40010C0C    原先地址里面的值    按位与上     0x40010C0C    地址里面的值左移0位并且取反。如下图   。

![image-20220629224253809](C:\Users\tianfuqiang\AppData\Roaming\Typora\typora-user-images\image-20220629224253809.png)

相与之后，除了将末位置零之外，其他位不变。



1<< ( 4 * N )   代表向左移动       N个4位    ，**==即把低4位看成一个整体   移动N位==**



#### 如何去除一个0，1二维数组的每一位。

0 1 1 0 1 0 0 0      bit  0  -> 7

1 1 0 0 0 0 1 1

例如一个二维数组，想顺序取出bit 0 -> 7.

1、定义一个指针* dot指向该数组。

2、unsigned char  byte = dot[i]

3、和1相与得原位置位

```c
for(b = 7; b >= 0; b++)
{
    bit[7 - b] = (byte & (1 << b)) >> b
}
```





##### 强制对地址进行指针类型转换

**地址的值只是一个常数**

(unsigned int *)0x500:将地址0x500强制转化为int型指针   **这里即把  ==(unsigned int *)0x500==  这一个整体看成一个指针变量，这个指针变量指向0x500这个地址。
*(unsigned int *)0x500=0x10：对地址为0x500的内容里面赋值为0x10



#### 字节  比特之间的换算及称呼

1字节（byte） =  8 比特（bit）   bit也成为位



## printf函数

### 转换说明符

**%a**        浮点数、十六进制数字和p-计数法(C99)
**%A**         浮点数、十六进制数字和P-计数法(C99)
**%c**         一个字符
**%d**          有符号十进制整数
**%e**        浮点数、e-计数法
**%E** 		浮点数、E-计数法
**%f** 		浮点数、十进制计数法
**%g** 		根据数值类型不同自动选择%f或%e。
**%e**		格式在指数小于-4或者大于等于精度时使用
**%G** 		根据数值类型不同自动选择%f或%E。
**%E**		格式在指数小于-4或者大于等于精度时使用
**%i** 		有符号十进制整数(与%d相同)
**%o** 		无符号八进制整数
**%p**		 指针
**%s** 		字符串
**%u** 		无符号十进制整数
**%x** 		使用十六进制数字0-f的**无符号十六进制整数**
**%X**		 使用十六进制数字0-F的无符号十六进制整数
**%%** 		打印一个百分号
————————————————
版权声明：本文为CSDN博主「qiucanghuai」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qiucanghuai/article/details/6469980  



## 操作符

| ：逻辑或运算符。

### 

## 指针

字符串和指针”赋值“和整形数据用指针定义赋值的区别。

```c
int * p;
int a = 5;
p = &a;        我们说  p ->  a,且*p = 5;

//字符串和指针
const char * p;
p = "i am a fool";这是正确赋值语句，就是将p指向这个常量字符串。    *p = "i am a fool"这是错误语句。
printf("%s", p);    可以打印p 指向的字符串。
```





### 字符串和字符串函数

数组和指针都可以定义字符串，指针更好一些。

char  * head  =  “tian fu qiang” v                  （head++）代表指针每加一次，他所指向的位置就递加一个，指向下一个位置。

看如下代码：

```c
    const char * str1 = "tian fu qiang 111";
    puts(str1 + 2);
```

这里的输出为 **“an fu qiang 111"**    从第3个字符开始输出。

指针定义字符串有它的**缺点**。就是==不能更改字符串里面的字面量==。





==空字符和空指针==

**空字符**：  空字符(或'\0')是用于标记C字符串末尾的字符，其对应字符编码是0。由于其他字符的编码不可能是0，所以不可能是
字符串的一部分。

**空指针**  ：   空指针(或NULL) 有一个值， ==该值不会与**任何数据的有效地址**对应==。通常， 函数使用它返回一个有效地址表示某些特殊情况发生，例如遇到文件结尾或未能按预期执行。
空字符是整数类型，而**空指针是指针类型**。两者有时容易混淆的原因是：它们都可以用数值0来表示。但是，从概念上看，两者是不同类型的0。另外，空字符是一个字符，占1字节；而空指针是一个地址，通常占4字节。



### 字符串输入函数

**gets()函数**

如何储存输入函数，

1、读取整行输入

2、直至遇到换行符， 然后丢弃换行符， 储存其余字符， 

3、并在这些字符的末尾添加一个空字符使其成为1个 C 字符串。  

**gets()函数的缺点。**看如下代码

```c
    char a[5];
    gets(a);
    puts(a);
```

我输入tianfuqiang,并不会报错，因为gets函数只知道a数组的起始地址，并不知道a有多大，我输入的已经远超a数组大小。但并没有报错。如果输入的字符串过长， 会导致缓冲区溢出 ^ buffer overflow ) , 即多余的字符超出了指定的目标空间。如果这些多余的字符只是占用了尚未使用的内存， 就不会立即出现问题： 。



**fgets()函数**

1、fgets ( )函数的第 2 个参数指明了**读入字符的最大数量**。 如果该参数的值是 n， 那么 fgets ( ) 将读入 n-1 个字符， 或者读到遇到的第一个换行符为止。  

2、如果 fgets () 读到一个换行符， 会把它储存在字符串中。 这点与 gets( )不同， getS()会丢弃换行符。  

3、fgets ( ） 函数的第 3 个参数指明要读入的文件。 如果读入**从键盘输入的数据， 则以 stdin ( 标准输入） 作为参数**， 该标识符定义在 stdio.h 中  



**gets()函数**    ：gets_s(words, STLEN);  

1、gets_S ( )只从标准输入中读取数据， 所以不需要第 3 个参数。  

2、gets_s ( )读到换行符， 会丢弃它。  

3、gets_s ( ) 读到最大字符数都没有读到换行符， 会执行以下几步。 

（1）、首先把目标数组中的首字符设置为空字符

（2）、 读取并丢弃随后的输入直至读到换行符或文件结尾， 然后返回空指针。 接着， 调用
依赖实现的“ 处理函数”（ 或你选择的其他函数）， 可能会中止或退出程序。  



**scanf函数**

scanf（“%10s”，a）;指定了输入长度

读入结束标志：

1、读到第一个空白字符（ **空行、 空格、 制表符或换行符**） 作为字符串的结束  

2、读满 10 个字符  

返回值：

scanf( }函数返回一个整数值， **该值等于 scanfO 成功==读取的项数==**         或          **EOF( 读到文件结尾时返回 EOF)**  

```c
    int a[5], b[10];
    int count;
    count = scanf("%5s %5s", a, b);
    printf("%d", count);
```

输入tian tian    返回值为2.



### 字符串输出函数

**puts函数**

puts( )函数很容易使用， 只需把**字符串的地址**作为参数**传递给它**即可。  





**常量静态字符串**想用指针指向它，必须加上==const==关键字

```c
    char * p;
    * p = "i am fool";
```

以上代码会报错。![image-20220707101042860](https://raw.githubusercontent.com/dalongmaot/arm_linux/main/imgs/image-20220707101042860.png)





**数组名代表的是地址，表示该数组第一个元素的地址。**



指针变量大小为**8**个字节



![image-20220706102804622](https://raw.githubusercontent.com/dalongmaot/arm_linux/main/imgs/image-20220706102804622.png)



==计算机中存储器的容量是以***字节***为基本单位的==

指针和数组

***重要***

c语言中指针和数组的特殊表示关系

```c
int * a;
*(a + i)  =  a[i];
这里是一种特殊表示方式（就是这样定义的），a依然占8个字节，是一个指针变量。
```

关于函数的形参， 还有一点要注意。 只有在==函数原型==或==函数定义头==中， 才**可以用 int ar[ ]代替 int *  a**.

int sum (int ar[], int n);
int *ar 形式和 int ar[ ] 形式都表示 ar 是一个指向 int 的指针。 但是， int ar[ ]只能用于声明
形式参数。  





```c
int main(void)
{
    short dates[SIZE];
    short * pti;
    short index;
    double bills[SIZE];
    double * ptf;
    pti = dates;
    ptf = bills;
    printf("%23s %15s\n", "short", "double");
    for(index = 0; index < SIZE; index++)
    {
        printf("pointers + %d: %10p %10p\n", index, pti +index,ptf + index);
    }
    system("pause");
    return 0;

}
```

输出结果：![image-20220629201736481](C:\Users\tianfuqiang\AppData\Roaming\Typora\typora-user-images\image-20220629201736481.png)



可以看到**<u>指针变量加1</u>**，  他是变成数组下一个变量的地址。

![](C:\Users\tianfuqiang\AppData\Roaming\Typora\typora-user-images\image-20220629201920260.png)

显然可以看出该电脑是64位的电脑。   16^16^ = 2^64



### 编译时头文件的查找

<>    去编译器目录底下找，范围窄一些

“   ”     去编译器底下，同时去该程序所在的文件目录底下去找。









